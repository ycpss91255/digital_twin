
//=======================================================
//  This code is generated by K-SONIC Co.
//  for Ultrasonic Welder 20K Machine
//=======================================================
//
//
//  %%kaman equation
//  fp = abs(Kalman.Est_t - Kalman.Mea_p); % filter performance parameter
//  Kalman.Mea_p = MEA;
//  Kalman.KG = (Kalman.a*Kalman.KG + fp)/(Kalman.a*(1+Kalman.KG) + fp);
//  Kalman.Est_t = Kalman.Est_t + (Kalman.a*Kalman.KG+fp)*(MEA-Kalman.Est_t)/(Kalman.a*(1+Kalman.KG)+fp);



// ============================================================================
// Revision History:
// ============================================================================
//   Ver.: |Author:   |Mod. Date:    |Changes Made:
//   V1.0  |Shih-An Li|02/01/2011    | adaptive kalman filter
// ============================================================================
`timescale 10ns / 1ns
module  kfa_v2(
    iClk_50M,   // 50 clk
    iRst_n,     // iRst_n 
    
    iData,      // sensor data 
    iDval,      // data valid trigger

    
    oEstData,   // estimate value
    oDval
    

);
//=======================================================
//  PARAMETER declarations
//=======================================================
parameter   DATAWIDTH = 32;  // fix point, inter 16bit, float 16bit
parameter   Wei = 12;
//=======================================================
//  PORT declarations
//=======================================================

input                       iClk_50M;   // 50 clk
input                       iRst_n;     // iRst_n 
    
input   [15: 0]    iData;      // sensor data
input                       iDval;      // data valid trigger

    
output  [DATAWIDTH-1: 0]    oEstData;   // estimate value

output  reg                 oDval;      // output data valid trigger
    
    


//=======================================================
//  REG/WIRE declarations
//=======================================================
reg     [DATAWIDTH-1: 0]    rKG_p, rKG, rWei, rWei_A;    // kalman filter gain
reg     [DATAWIDTH-1: 0]    rEst, rEst_p, rEma_p, rEma, rEma_in;    //  
reg     [DATAWIDTH-1: 0]    rTempEma;    // k 
reg                         rDval;
reg     [DATAWIDTH-1:0]     rTempKG_up[1:0], rTempKG_Dn[1:0];

reg     [47:0]   rWeiMul[0:1];//16bit*32bit
wire    [47:0]  wMulResult[1:0];
wire    wDivDval, wDivDval_2;
wire    [31:0]  wDivQuotient, wDivQuotient_2, wRemainder;
//=======================================================
//  Structural coding
//=======================================================
assign oEstData = rEst[31:16];// obtain integer

// level 1
always@(posedge iClk_50M or negedge iRst_n) begin
    if(!iRst_n) begin
        rEma_in <= 0;
        rDval <= 0;
    end
    else begin
        if({rDval,iDval}==2'b01)
            rEma_in <= {iData,16'd0};  // data.0000
        else
            rEma_in <= rEma_in;
        rDval <= iDval;
    end
end

// level 2, calculate 
reg [3:0]   rState;
reg         rDlyDval;
reg [6:0]   rDivCnt;
always@(posedge iClk_50M or negedge iRst_n) begin
if(!iRst_n) begin
    rWei_A <= 0;
    rDlyDval <= 0;
    rState <= 0;
    rEma_p <= 0;
    rEst_p <= 0;  // 0.75
    rTempKG_up[0] <= 0;        rTempKG_Dn[0] <= 0;
    rTempKG_up[1] <= 0;        rTempKG_Dn[1] <= 0;
    rTempEma <= 0;
    rEma <= 0;
    rKG <= 0;
    rKG_p <= 32'b0000_0000_0000_0000_0110_0000_0000_0000;
    oDval <= 0;
    rEst <= 0;
    rWeiMul[0] <= 0; rWeiMul[1] <= 0;
    rDivCnt <=0;
    rWei <= 0;
end
else begin
    rDlyDval <= rDval;
    rTempKG_up[0] <= rTempKG_up[0];        rTempKG_Dn[0] <= rTempKG_Dn[0];
    rTempKG_up[1] <= rTempKG_up[1];        rTempKG_Dn[1] <= rTempKG_Dn[1];
//    rTempKG_up[2] <= rTempKG_up[2];
    rWeiMul[0] <= rWeiMul[0]; rWeiMul[1] <= rWeiMul[1];
    rTempEma <= rTempEma;
    rState <= rState;
    rEst_p <= rEst_p;
    rKG_p <= rKG_p;
    rEma_p <= rEma_p;
    oDval <= oDval;
    rEst <= rEst;
    rDivCnt <=rDivCnt;
    rWei <= rWei;
    rEma <= rEma;
    rWei_A <= rWei_A;
    case(rState)
        0: begin  // idle
            oDval <= 0;
            rWei <= 0;
           if({rDlyDval, rDval}==2'b01) begin
               rEma <= rEma_in;
               rState <= 1;
           end
           else begin
               rState <= rState;  
           end
        end
        1: begin
            // pipe 1
            if( rEma_p >= rEst_p) // obtain absolute value
                rTempEma <= rEma_p - rEst_p;
            else
                rTempEma <= rEst_p - rEma_p;
            rTempKG_up[0] <= rKG_p;
            rTempKG_Dn[0] <= 32'h00010000|rKG_p;  // KG_p +1
            rState <= 2;
        end
        2: begin
            rTempKG_up[1] <= rTempKG_up[0]+(rTempEma>>Wei);
            rTempKG_Dn[1] <= rTempKG_Dn[0] + (rTempEma>>Wei);
            rState <= 3;
            rDivCnt <=0;
        end
        3: begin // calculate Kalman Gain
            if(rDivCnt > 4 ) begin
                rState <= 4; // delay for divisor
                rKG <= {16'd0,wDivQuotient[15:0]};
                rDivCnt <= 0;
            end
            else begin
                rState <= rState;
                rDivCnt <= rDivCnt+1;
            end
            rWei <= 'd1<<(DATAWIDTH/2);
        end
        4: begin
            rWei_A <= rWei-rKG;  // (1-KG)
            rWeiMul[0] <= wMulResult[0];// rKG[15:0]*rEma;  // 16bit * 32 bit
            rState <= 5;
        end
        5: begin // cal est value
            rWeiMul[1] <= wMulResult[1];//rWei * rEst_p; 
            rWeiMul[0] <= rWeiMul[0];
            oDval <= 0;
            rState <= 6;
            rDivCnt <= 0;
        end
        6: begin // cal est value
            rEst <= rWeiMul[1][47:16] + rWeiMul[0][47:16];
            oDval <= 1;
            rState <= 7;
            rDivCnt <= 0;
        end
        7: begin  // update
            rEma_p <= rEma; // update measurment 
            rKG_p <= rKG;  
            rEst_p <= rEst;
            rState <= 0;
            rDivCnt <= 0;
        end
        default: begin
             rState <= 0;
        end
    endcase

end
end

wwmul mul1(
    .dataa(rKG[15:0]),
    .datab(rEma),
    .result(wMulResult[0])
    );
    
wwmul mul2(
    .dataa(rWei_A[15:0]),
    .datab(rEst_p),
    .result(wMulResult[1])
    );

kaldiv div1(
//        .clken(rDivTrig),
        .clock(iClk_50M),
        .numer({rTempKG_up[1][15:0],16'd0}),
        .denom(rTempKG_Dn[1]),
        .quotient(wDivQuotient),
        .remain(wRemainder)
        );
endmodule
